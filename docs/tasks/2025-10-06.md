# 태스크 작업 보고서 - 로그인 API JSON 지원 및 Swagger 문서화

**날짜**: 2025-10-06  
**작업자**: Claude Code  
**상태**: ✅ 완료  

## 작업 개요

프론트엔드에서 로그인 시 500 에러가 발생하는 문제를 분석하고, LoginFilter를 JSON 전용으로 수정하며, Swagger 문서에 로그인 엔드포인트를 추가한 작업입니다.

## 수행한 작업 목록

### 1. 로그인 API 문제 분석
- **문제**: 프론트엔드에서 로그인 요청 시 500 Internal Server Error 발생
- **원인**: 
  - LoginFilter가 form-data만 처리 가능 (JSON 미지원)
  - 프론트엔드는 JSON으로 요청하지만 헤더는 form-urlencoded로 설정
  - 필드명 불일치: 프론트엔드는 `username` 사용, 실제로는 이메일 전송

### 2. LoginRequestDto 생성
- **파일**: `src/main/java/com/energyfactory/energy_factory/dto/LoginRequestDto.java`
- **필드**:
  ```java
  private String email;    // 사용자 이메일
  private String password; // 비밀번호
  ```
- **용도**: JSON 요청 파싱 및 Swagger 문서 스키마 정의

### 3. LoginFilter JSON 지원 추가
- **파일**: `src/main/java/com/energyfactory/energy_factory/jwt/LoginFilter.java`
- **변경사항**:
  - ObjectMapper를 사용한 JSON 파싱 로직 추가
  - Content-Type이 application/json일 때만 처리하도록 수정
  - form-data 지원 제거 (JSON 전용)
  - email 필드로 인증 처리 (Spring Security 내부적으로는 username으로 전달)

### 4. Swagger 문서에 로그인 엔드포인트 추가
- **파일**: `src/main/java/com/energyfactory/energy_factory/config/SwaggerConfig.java`
- **추가 내용**:
  - `/api/auth/login` POST 엔드포인트 수동 문서화
  - Request/Response 스키마 정의
  - 인증 태그 추가
  - 성공/실패 응답 예시 포함

### 5. PasswordEncoder Bean 중복 문제 해결
- **문제**: SecurityConfig와 PasswordEncoderConfig에 중복된 Bean 정의
- **에러**: `DelegatingPasswordEncoder`가 기본 인코더를 찾지 못함
- **해결**: SecurityConfig에서 `bCryptPasswordEncoder()` Bean 제거
- **결과**: PasswordEncoderConfig의 `passwordEncoder()` Bean만 사용

### 6. 테스트 및 검증
- **JSON 요청 테스트**: 정상 동작 확인 (401 응답 - 인증 실패)
- **form-data 요청 테스트**: JSON 전용으로 수정되어 거부됨
- **Swagger UI 접근**: http://localhost:8080/swagger-ui/index.html 에서 확인 가능
- **BCrypt 사용자 로그인 테스트**: 새 계정으로 정상 로그인 확인

## API 스펙 최종 정리

### 로그인 API
```
POST /api/auth/login
Content-Type: application/json

Request Body:
{
  "email": "user@example.com",
  "password": "password123"
}

Response (성공):
{
  "status": 200,
  "code": "20000000",
  "desc": "로그인에 성공했습니다.",
  "data": {
    "accessToken": "eyJ...",
    "refreshToken": "eyJ...",
    "tokenType": "Bearer"
  }
}

Response (실패):
{
  "status": 401,
  "code": "40100000",
  "desc": "로그인에 실패했습니다.",
  "data": null
}
```

## 발생했던 문제들

### 문제 1: 로그인 API 500 Internal Server Error
**증상**: 프론트엔드에서 로그인 요청 시 500 에러 발생  
**원인**: 
- LoginFilter가 JSON 요청을 처리하지 못함 (form-data만 지원)
- 프론트엔드는 JSON으로 요청하지만 헤더는 form-urlencoded
- 필드명 불일치 (username vs email)

**해결**: LoginFilter를 JSON 전용으로 수정하고 email 필드 사용

### 문제 2: PasswordEncoder Bean 중복 정의
**증상**: `DelegatingPasswordEncoder`에서 기본 인코더를 찾지 못하는 에러  
**원인**: SecurityConfig와 PasswordEncoderConfig에서 중복된 PasswordEncoder Bean 생성  
**해결**: SecurityConfig에서 중복 Bean 제거, PasswordEncoderConfig의 Bean만 사용

### 문제 3: 기존 사용자 비밀번호 평문 저장
**증상**: 새로 생성한 사용자는 로그인되지만 기존 사용자는 인증 실패  
**원인**: 기존 사용자는 평문 비밀번호로 저장되어 BCrypt 인증 실패  
**해결**: 새 계정 생성으로 BCrypt 암호화된 비밀번호 사용

## 주요 결정 사항

1. **JSON 전용 지원**: form-data 지원을 제거하고 JSON만 처리하도록 통일
2. **필드명 변경**: `username` → `email`로 변경하여 직관적으로 개선
3. **Swagger 수동 문서화**: LoginFilter는 Controller가 아니어서 수동으로 문서 추가
4. **PasswordEncoder 통일**: PasswordEncoderConfig의 Bean만 사용하여 중복 제거

## 프론트엔드 연동 가이드

### 요청 방법
```javascript
const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        email: userEmail,
        password: userPassword
    })
});
```

### 주의사항
- Content-Type은 반드시 `application/json`으로 설정
- 필드명은 `email`과 `password` 사용 (순서는 무관)
- form-data 형식은 지원하지 않음

## 기술적 고려사항

### Spring Security와의 통합
- Spring Security는 내부적으로 `username`이라는 이름을 사용
- LoginFilter에서 `email`을 받아 `username` 파라미터로 전달
- `CustomUserDetailService.loadUserByUsername()`에서 email로 사용자 조회

### LoginFilter vs Controller 방식
- LoginFilter 방식 유지: Spring Security 표준 인증 프로세스 활용
- AuthenticationManager와 자연스러운 통합
- JWT 발급 시점 제어 용이

## 다음 단계

- [x] 코드 변경 완료
- [x] 로컬 테스트 완료
- [x] Swagger 문서 확인
- [ ] EC2 배포 (GitHub Actions 자동 배포)
- [ ] 프론트엔드 개발자에게 API 스펙 전달

## 참고사항

- LoginFilter는 Spring Security Filter이므로 Swagger가 자동으로 인식하지 못함
- SwaggerConfig에서 수동으로 엔드포인트를 추가하여 문서화
- JSON 필드 순서는 파싱에 영향 없음 (JSON 객체 특성)